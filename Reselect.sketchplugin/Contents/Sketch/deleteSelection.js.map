{"version":3,"sources":["webpack://exports/webpack/bootstrap","webpack://exports/./node_modules/@skpm/fs/index.js","webpack://exports/./node_modules/@skpm/fs/utils.js","webpack://exports/./node_modules/@skpm/path/index.js","webpack://exports/./node_modules/@skpm/path/sketch-specifics.js","webpack://exports/./src/sketch/deleteSelection.js","webpack://exports/./src/sketch/utilities/utilities.js","webpack://exports/external \"buffer\"","webpack://exports/external \"sketch/dom\"","webpack://exports/external \"sketch/settings\"","webpack://exports/external \"sketch/ui\"","webpack://exports/external \"util\""],"names":["deleteSelection","document","DOM","documentId","scriptPath","path","documentFilePath","fs","data","documentFile","JSON","options","i","UI","type","possibleValues","value","utils","saveGlobalSetting","Settings","loadGlobalSetting","key","savePluginSetting","loadPluginSetting","saveSessionVariable","loadSessionVariable","openURL","url","nsurl","NSURL","NSWorkspace","showToast","message"],"mappings":";;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,YAAY,mBAAO,CAAC,iDAAS;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACpbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,mBAAO,CAAC,iDAAS;AACvC;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,yEAAoB;;AAElD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,8BAA8B;AACpE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,yBAAyB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,WAAW;AACX;AACA,qCAAqC;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA,gDAAgD;AAChD;AACA,WAAW;AACX;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA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","file":"deleteSelection.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/sketch/deleteSelection.js\");\n","// TODO: async. Should probably be done with NSFileHandle and some notifications\n// TODO: file descriptor. Needs to be done with NSFileHandle\nvar Buffer = require(\"buffer\").Buffer;\nvar utils = require(\"./utils\");\nvar parseStat = utils.parseStat;\nvar fsError = utils.fsError;\nvar fsErrorForPath = utils.fsErrorForPath;\nvar encodingFromOptions = utils.encodingFromOptions;\nvar NOT_IMPLEMENTED = utils.NOT_IMPLEMENTED;\n\nmodule.exports.constants = {\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1,\n};\n\nmodule.exports.access = NOT_IMPLEMENTED(\"access\");\n\nmodule.exports.accessSync = function (path, mode) {\n  mode = mode | 0;\n  var fileManager = NSFileManager.defaultManager();\n\n  switch (mode) {\n    case 0:\n      canAccess = module.exports.existsSync(path);\n      break;\n    case 1:\n      canAccess = Boolean(Number(fileManager.isExecutableFileAtPath(path)));\n      break;\n    case 2:\n      canAccess = Boolean(Number(fileManager.isWritableFileAtPath(path)));\n      break;\n    case 3:\n      canAccess =\n        Boolean(Number(fileManager.isExecutableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isWritableFileAtPath(path)));\n      break;\n    case 4:\n      canAccess = Boolean(Number(fileManager.isReadableFileAtPath(path)));\n      break;\n    case 5:\n      canAccess =\n        Boolean(Number(fileManager.isReadableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isExecutableFileAtPath(path)));\n      break;\n    case 6:\n      canAccess =\n        Boolean(Number(fileManager.isReadableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isWritableFileAtPath(path)));\n      break;\n    case 7:\n      canAccess =\n        Boolean(Number(fileManager.isReadableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isWritableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isExecutableFileAtPath(path)));\n      break;\n  }\n\n  if (!canAccess) {\n    throw new Error(\"Can't access \" + String(path));\n  }\n};\n\nmodule.exports.appendFile = NOT_IMPLEMENTED(\"appendFile\");\n\nmodule.exports.appendFileSync = function (file, data, options) {\n  if (!module.exports.existsSync(file)) {\n    return module.exports.writeFileSync(file, data, options);\n  }\n\n  var handle = NSFileHandle.fileHandleForWritingAtPath(file);\n  handle.seekToEndOfFile();\n\n  var encoding = encodingFromOptions(options, \"utf8\");\n\n  var nsdata = Buffer.from(\n    data,\n    encoding === \"NSData\" || encoding === \"buffer\" ? undefined : encoding\n  ).toNSData();\n\n  handle.writeData(nsdata);\n};\n\nmodule.exports.chmod = NOT_IMPLEMENTED(\"chmod\");\n\nmodule.exports.chmodSync = function (path, mode) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.setAttributes_ofItemAtPath_error(\n    {\n      NSFilePosixPermissions: mode,\n    },\n    path,\n    err\n  );\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n};\n\nmodule.exports.chown = NOT_IMPLEMENTED(\"chown\");\nmodule.exports.chownSync = NOT_IMPLEMENTED(\"chownSync\");\n\nmodule.exports.close = NOT_IMPLEMENTED(\"close\");\nmodule.exports.closeSync = NOT_IMPLEMENTED(\"closeSync\");\n\nmodule.exports.copyFile = NOT_IMPLEMENTED(\"copyFile\");\n\nmodule.exports.copyFileSync = function (path, dest, flags) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.copyItemAtPath_toPath_error(path, dest, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, false, err.value());\n  }\n};\n\nmodule.exports.createReadStream = NOT_IMPLEMENTED(\"createReadStream\");\nmodule.exports.createWriteStream = NOT_IMPLEMENTED(\"createWriteStream\");\n\nmodule.exports.exists = NOT_IMPLEMENTED(\"exists\");\n\nmodule.exports.existsSync = function (path) {\n  var fileManager = NSFileManager.defaultManager();\n  return Boolean(Number(fileManager.fileExistsAtPath(path)));\n};\n\nmodule.exports.fchmod = NOT_IMPLEMENTED(\"fchmod\");\nmodule.exports.fchmodSync = NOT_IMPLEMENTED(\"fchmodSync\");\nmodule.exports.fchown = NOT_IMPLEMENTED(\"fchown\");\nmodule.exports.fchownSync = NOT_IMPLEMENTED(\"fchownSync\");\nmodule.exports.fdatasync = NOT_IMPLEMENTED(\"fdatasync\");\nmodule.exports.fdatasyncSync = NOT_IMPLEMENTED(\"fdatasyncSync\");\nmodule.exports.fstat = NOT_IMPLEMENTED(\"fstat\");\nmodule.exports.fstatSync = NOT_IMPLEMENTED(\"fstatSync\");\nmodule.exports.fsync = NOT_IMPLEMENTED(\"fsync\");\nmodule.exports.fsyncSync = NOT_IMPLEMENTED(\"fsyncSync\");\nmodule.exports.ftruncate = NOT_IMPLEMENTED(\"ftruncate\");\nmodule.exports.ftruncateSync = NOT_IMPLEMENTED(\"ftruncateSync\");\nmodule.exports.futimes = NOT_IMPLEMENTED(\"futimes\");\nmodule.exports.futimesSync = NOT_IMPLEMENTED(\"futimesSync\");\n\nmodule.exports.lchmod = NOT_IMPLEMENTED(\"lchmod\");\nmodule.exports.lchmodSync = NOT_IMPLEMENTED(\"lchmodSync\");\nmodule.exports.lchown = NOT_IMPLEMENTED(\"lchown\");\nmodule.exports.lchownSync = NOT_IMPLEMENTED(\"lchownSync\");\n\nmodule.exports.link = NOT_IMPLEMENTED(\"link\");\n\nmodule.exports.linkSync = function (existingPath, newPath) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.linkItemAtPath_toPath_error(existingPath, newPath, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(existingPath, undefined, err.value());\n  }\n};\n\nmodule.exports.lstat = NOT_IMPLEMENTED(\"lstat\");\n\nmodule.exports.lstatSync = function (path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.attributesOfItemAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n\n  return parseStat(result);\n};\n\nmodule.exports.mkdir = NOT_IMPLEMENTED(\"mkdir\");\n\nmodule.exports.mkdirSync = function (path, options) {\n  var mode = 0o777;\n  var recursive = false;\n  if (options && options.mode) {\n    mode = options.mode;\n  }\n  if (options && options.recursive) {\n    recursive = options.recursive;\n  }\n  if (typeof options === \"number\") {\n    mode = options;\n  }\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.createDirectoryAtPath_withIntermediateDirectories_attributes_error(\n    path,\n    recursive,\n    {\n      NSFilePosixPermissions: mode,\n    },\n    err\n  );\n\n  if (err.value() !== null) {\n    throw new Error(err.value());\n  }\n};\n\nmodule.exports.mkdtemp = NOT_IMPLEMENTED(\"mkdtemp\");\n\nmodule.exports.mkdtempSync = function (path) {\n  function makeid() {\n    var text = \"\";\n    var possible =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n    for (var i = 0; i < 6; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n  var tempPath = path + makeid();\n  module.exports.mkdirSync(tempPath);\n  return tempPath;\n};\n\nmodule.exports.open = NOT_IMPLEMENTED(\"open\");\nmodule.exports.openSync = NOT_IMPLEMENTED(\"openSync\");\n\nmodule.exports.read = NOT_IMPLEMENTED(\"read\");\n\nmodule.exports.readdir = NOT_IMPLEMENTED(\"readdir\");\n\nmodule.exports.readdirSync = function (path, options) {\n  var encoding = encodingFromOptions(options, \"utf8\");\n  var fileManager = NSFileManager.defaultManager();\n  var paths = fileManager.subpathsAtPath(path);\n  var arr = [];\n  for (var i = 0; i < paths.length; i++) {\n    var pathName = paths[i];\n    arr.push(encoding === \"buffer\" ? Buffer.from(pathName) : String(pathName));\n  }\n  return arr;\n};\n\nmodule.exports.readFile = NOT_IMPLEMENTED(\"readFile\");\n\nmodule.exports.readFileSync = function (path, options) {\n  var encoding = encodingFromOptions(options, \"buffer\");\n  var fileManager = NSFileManager.defaultManager();\n  var data = fileManager.contentsAtPath(path);\n  if (!data) {\n    throw fsErrorForPath(path, false);\n  }\n\n  var buffer = Buffer.from(data);\n\n  if (encoding === \"buffer\") {\n    return buffer;\n  } else if (encoding === \"NSData\") {\n    return buffer.toNSData();\n  } else {\n    return buffer.toString(encoding);\n  }\n};\n\nmodule.exports.readlink = NOT_IMPLEMENTED(\"readlink\");\n\nmodule.exports.readlinkSync = function (path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.destinationOfSymbolicLinkAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n\n  return String(result);\n};\n\nmodule.exports.readSync = NOT_IMPLEMENTED(\"readSync\");\n\nmodule.exports.realpath = NOT_IMPLEMENTED(\"realpath\");\nmodule.exports.realpath.native = NOT_IMPLEMENTED(\"realpath.native\");\n\nmodule.exports.realpathSync = function (path) {\n  return String(\n    NSString.stringWithString(path).stringByResolvingSymlinksInPath()\n  );\n};\n\nmodule.exports.realpathSync.native = NOT_IMPLEMENTED(\"realpathSync.native\");\n\nmodule.exports.rename = NOT_IMPLEMENTED(\"rename\");\n\nmodule.exports.renameSync = function (oldPath, newPath) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.moveItemAtPath_toPath_error(oldPath, newPath, err);\n\n  var error = err.value();\n\n  if (error !== null) {\n    // if there is already a file, we need to overwrite it\n    if (\n      String(error.domain()) === \"NSCocoaErrorDomain\" &&\n      Number(error.code()) === 516\n    ) {\n      var err2 = MOPointer.alloc().init();\n      fileManager.replaceItemAtURL_withItemAtURL_backupItemName_options_resultingItemURL_error(\n        NSURL.fileURLWithPath(newPath),\n        NSURL.fileURLWithPath(oldPath),\n        null,\n        NSFileManagerItemReplacementUsingNewMetadataOnly,\n        null,\n        err2\n      );\n      if (err2.value() !== null) {\n        throw fsErrorForPath(oldPath, undefined, err2.value());\n      }\n    } else {\n      throw fsErrorForPath(oldPath, undefined, error);\n    }\n  }\n};\n\nmodule.exports.rmdir = NOT_IMPLEMENTED(\"rmdir\");\n\nmodule.exports.rmdirSync = function (path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var isDirectory = module.exports.lstatSync(path).isDirectory();\n  if (!isDirectory) {\n    throw fsError(\"ENOTDIR\", {\n      path: path,\n      syscall: \"rmdir\",\n    });\n  }\n  fileManager.removeItemAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, true, err.value(), \"rmdir\");\n  }\n};\n\nmodule.exports.stat = NOT_IMPLEMENTED(\"stat\");\n\n// the only difference with lstat is that we resolve symlinks\n//\n// > lstat() is identical to stat(), except that if pathname is a symbolic\n// > link, then it returns information about the link itself, not the file\n// > that it refers to.\n// http://man7.org/linux/man-pages/man2/lstat.2.html\nmodule.exports.statSync = function (path) {\n  return module.exports.lstatSync(module.exports.realpathSync(path));\n};\n\nmodule.exports.symlink = NOT_IMPLEMENTED(\"symlink\");\n\nmodule.exports.symlinkSync = function (target, path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.createSymbolicLinkAtPath_withDestinationPath_error(\n    path,\n    target,\n    err\n  );\n\n  if (err.value() !== null) {\n    throw new Error(err.value());\n  }\n};\n\nmodule.exports.truncate = NOT_IMPLEMENTED(\"truncate\");\n\nmodule.exports.truncateSync = function (path, len) {\n  var hFile = NSFileHandle.fileHandleForUpdatingAtPath(sFilePath);\n  hFile.truncateFileAtOffset(len || 0);\n  hFile.closeFile();\n};\n\nmodule.exports.unlink = NOT_IMPLEMENTED(\"unlink\");\n\nmodule.exports.unlinkSync = function (path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var isDirectory = module.exports.lstatSync(path).isDirectory();\n  if (isDirectory) {\n    throw fsError(\"EPERM\", {\n      path: path,\n      syscall: \"unlink\",\n    });\n  }\n  var result = fileManager.removeItemAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, false, err.value());\n  }\n};\n\nmodule.exports.unwatchFile = NOT_IMPLEMENTED(\"unwatchFile\");\n\nmodule.exports.utimes = NOT_IMPLEMENTED(\"utimes\");\n\nmodule.exports.utimesSync = function (path, aTime, mTime) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.setAttributes_ofItemAtPath_error(\n    {\n      NSFileModificationDate: aTime,\n    },\n    path,\n    err\n  );\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n};\n\nmodule.exports.watch = NOT_IMPLEMENTED(\"watch\");\nmodule.exports.watchFile = NOT_IMPLEMENTED(\"watchFile\");\n\nmodule.exports.write = NOT_IMPLEMENTED(\"write\");\n\nmodule.exports.writeFile = NOT_IMPLEMENTED(\"writeFile\");\n\nmodule.exports.writeFileSync = function (path, data, options) {\n  var encoding = encodingFromOptions(options, \"utf8\");\n\n  var nsdata = Buffer.from(\n    data,\n    encoding === \"NSData\" || encoding === \"buffer\" ? undefined : encoding\n  ).toNSData();\n\n  nsdata.writeToFile_atomically(path, true);\n};\n\nmodule.exports.writeSync = NOT_IMPLEMENTED(\"writeSync\");\n","module.exports.parseStat = function parseStat(result) {\n  return {\n    dev: String(result.NSFileDeviceIdentifier),\n    // ino: 48064969, The file system specific \"Inode\" number for the file.\n    mode: result.NSFileType | result.NSFilePosixPermissions,\n    nlink: Number(result.NSFileReferenceCount),\n    uid: String(result.NSFileOwnerAccountID),\n    gid: String(result.NSFileGroupOwnerAccountID),\n    // rdev: 0, A numeric device identifier if the file is considered \"special\".\n    size: Number(result.NSFileSize),\n    // blksize: 4096, The file system block size for i/o operations.\n    // blocks: 8, The number of blocks allocated for this file.\n    atimeMs:\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    mtimeMs:\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    ctimeMs:\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    birthtimeMs:\n      Number(result.NSFileCreationDate.timeIntervalSince1970()) * 1000,\n    atime: new Date(\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ), // the 0.5 comes from the node source. Not sure why it's added but in doubt...\n    mtime: new Date(\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ),\n    ctime: new Date(\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ),\n    birthtime: new Date(\n      Number(result.NSFileCreationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ),\n    isBlockDevice: function () {\n      return result.NSFileType === NSFileTypeBlockSpecial;\n    },\n    isCharacterDevice: function () {\n      return result.NSFileType === NSFileTypeCharacterSpecial;\n    },\n    isDirectory: function () {\n      return result.NSFileType === NSFileTypeDirectory;\n    },\n    isFIFO: function () {\n      return false;\n    },\n    isFile: function () {\n      return result.NSFileType === NSFileTypeRegular;\n    },\n    isSocket: function () {\n      return result.NSFileType === NSFileTypeSocket;\n    },\n    isSymbolicLink: function () {\n      return result.NSFileType === NSFileTypeSymbolicLink;\n    },\n  };\n};\n\nvar ERRORS = {\n  EPERM: {\n    message: \"operation not permitted\",\n    errno: -1,\n  },\n  ENOENT: {\n    message: \"no such file or directory\",\n    errno: -2,\n  },\n  EACCES: {\n    message: \"permission denied\",\n    errno: -13,\n  },\n  ENOTDIR: {\n    message: \"not a directory\",\n    errno: -20,\n  },\n  EISDIR: {\n    message: \"illegal operation on a directory\",\n    errno: -21,\n  },\n};\n\nfunction fsError(code, options) {\n  var error = new Error(\n    code +\n      \": \" +\n      ERRORS[code].message +\n      \", \" +\n      (options.syscall || \"\") +\n      (options.path ? \" '\" + options.path + \"'\" : \"\")\n  );\n\n  Object.keys(options).forEach(function (k) {\n    error[k] = options[k];\n  });\n\n  error.code = code;\n  error.errno = ERRORS[code].errno;\n\n  return error;\n}\n\nmodule.exports.fsError = fsError;\n\nmodule.exports.fsErrorForPath = function fsErrorForPath(\n  path,\n  shouldBeDir,\n  err,\n  syscall\n) {\n  var fileManager = NSFileManager.defaultManager();\n  var doesExist = fileManager.fileExistsAtPath(path);\n  if (!doesExist) {\n    return fsError(\"ENOENT\", {\n      path: path,\n      syscall: syscall || \"open\",\n    });\n  }\n  var isReadable = fileManager.isReadableFileAtPath(path);\n  if (!isReadable) {\n    return fsError(\"EACCES\", {\n      path: path,\n      syscall: syscall || \"open\",\n    });\n  }\n  if (typeof shouldBeDir !== \"undefined\") {\n    var isDirectory = require(\"./index\").lstatSync(path).isDirectory();\n    if (isDirectory && !shouldBeDir) {\n      return fsError(\"EISDIR\", {\n        path: path,\n        syscall: syscall || \"read\",\n      });\n    } else if (!isDirectory && shouldBeDir) {\n      return fsError(\"ENOTDIR\", {\n        path: path,\n        syscall: syscall || \"read\",\n      });\n    }\n  }\n  return new Error(err || \"Unknown error while manipulating \" + path);\n};\n\nmodule.exports.encodingFromOptions = function encodingFromOptions(\n  options,\n  defaultValue\n) {\n  return options && options.encoding\n    ? String(options.encoding)\n    : options\n    ? String(options)\n    : defaultValue;\n};\n\nmodule.exports.NOT_IMPLEMENTED = function NOT_IMPLEMENTED(name) {\n  return function () {\n    throw new Error(\n      \"fs.\" +\n        name +\n        \" is not implemented yet. If you feel like implementing it, any contribution will be gladly accepted on https://github.com/skpm/fs\"\n    );\n  };\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar sketchSpecifics = require('./sketch-specifics')\n\n// we only expose the posix implementation since Sketch only runs on macOS\n\nvar CHAR_FORWARD_SLASH = 47\nvar CHAR_DOT = 46\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot) {\n  var res = ''\n  var lastSegmentLength = 0\n  var lastSlash = -1\n  var dots = 0\n  var code\n  for (var i = 0; i <= path.length; i += 1) {\n    if (i < path.length) code = path.charCodeAt(i)\n    else if (code === CHAR_FORWARD_SLASH) break\n    else code = CHAR_FORWARD_SLASH\n    if (code === CHAR_FORWARD_SLASH) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/')\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = ''\n                lastSegmentLength = 0\n              } else {\n                res = res.slice(0, lastSlashIndex)\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/')\n              }\n              lastSlash = i\n              dots = 0\n              continue\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = ''\n            lastSegmentLength = 0\n            lastSlash = i\n            dots = 0\n            continue\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += '/..'\n          else res = '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i)\n        else res = path.slice(lastSlash + 1, i)\n        lastSegmentLength = i - lastSlash - 1\n      }\n      lastSlash = i\n      dots = 0\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots\n    } else {\n      dots = -1\n    }\n  }\n  return res\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root\n  var base =\n    pathObject.base || (pathObject.name || '') + (pathObject.ext || '')\n  if (!dir) {\n    return base\n  }\n  if (dir === pathObject.root) {\n    return dir + base\n  }\n  return dir + sep + base\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = ''\n    var resolvedAbsolute = false\n    var cwd\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i -= 1) {\n      var path\n      if (i >= 0) {\n        path = arguments[i]\n      } else {\n        if (cwd === undefined) {\n          cwd = posix.dirname(sketchSpecifics.cwd())\n        }\n        path = cwd\n      }\n\n      path = sketchSpecifics.getString(path, 'path')\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue\n      }\n\n      resolvedPath = path + '/' + resolvedPath\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute)\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0) return '/' + resolvedPath\n      else return '/'\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath\n    } else {\n      return '.'\n    }\n  },\n\n  normalize: function normalize(path) {\n    path = sketchSpecifics.getString(path, 'path')\n\n    if (path.length === 0) return '.'\n\n    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n    var trailingSeparator =\n      path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH\n\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute)\n\n    if (path.length === 0 && !isAbsolute) path = '.'\n    if (path.length > 0 && trailingSeparator) path += '/'\n\n    if (isAbsolute) return '/' + path\n    return path\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    path = sketchSpecifics.getString(path, 'path')\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH\n  },\n\n  join: function join() {\n    if (arguments.length === 0) return '.'\n    var joined\n    for (var i = 0; i < arguments.length; i += 1) {\n      var arg = arguments[i]\n      arg = sketchSpecifics.getString(arg, 'path')\n      if (arg.length > 0) {\n        if (joined === undefined) joined = arg\n        else joined += '/' + arg\n      }\n    }\n    if (joined === undefined) return '.'\n    return posix.normalize(joined)\n  },\n\n  relative: function relative(from, to) {\n    from = sketchSpecifics.getString(from, 'from path')\n    to = sketchSpecifics.getString(to, 'to path')\n\n    if (from === to) return ''\n\n    from = posix.resolve(from)\n    to = posix.resolve(to)\n\n    if (from === to) return ''\n\n    // Trim any leading backslashes\n    var fromStart = 1\n    for (; fromStart < from.length; fromStart += 1) {\n      if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) break\n    }\n    var fromEnd = from.length\n    var fromLen = fromEnd - fromStart\n\n    // Trim any leading backslashes\n    var toStart = 1\n    for (; toStart < to.length; toStart += 1) {\n      if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) break\n    }\n    var toEnd = to.length\n    var toLen = toEnd - toStart\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen\n    var lastCommonSep = -1\n    var i = 0\n    for (; i <= length; i += 1) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1)\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i)\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0\n          }\n        }\n        break\n      }\n      var fromCode = from.charCodeAt(fromStart + i)\n      var toCode = to.charCodeAt(toStart + i)\n      if (fromCode !== toCode) break\n      else if (fromCode === CHAR_FORWARD_SLASH) lastCommonSep = i\n    }\n\n    var out = ''\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; i += 1) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (out.length === 0) out += '..'\n        else out += '/..'\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0) return out + to.slice(toStart + lastCommonSep)\n    else {\n      toStart += lastCommonSep\n      if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) toStart += 1\n      return to.slice(toStart)\n    }\n  },\n\n  toNamespacedPath: function toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path\n  },\n\n  dirname: function dirname(path) {\n    path = sketchSpecifics.getString(path, 'path')\n    if (path.length === 0) return '.'\n    var code = path.charCodeAt(0)\n    var hasRoot = code === CHAR_FORWARD_SLASH\n    var end = -1\n    var matchedSlash = true\n    for (var i = path.length - 1; i >= 1; i -= 1) {\n      code = path.charCodeAt(i)\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i\n          break\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.'\n    if (hasRoot && end === 1) return '//'\n    return path.slice(0, end)\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined)\n      ext = sketchSpecifics.getString(ext, 'ext')\n    path = sketchSpecifics.getString(path, 'path')\n\n    var start = 0\n    var end = -1\n    var matchedSlash = true\n    var i\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return ''\n      var extIdx = ext.length - 1\n      var firstNonSlashEnd = -1\n      for (i = path.length - 1; i >= 0; i -= 1) {\n        var code = path.charCodeAt(i)\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1\n            break\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false\n            firstNonSlashEnd = i + 1\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1\n              end = firstNonSlashEnd\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd\n      else if (end === -1) end = path.length\n      return path.slice(start, end)\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1\n            break\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false\n          end = i + 1\n        }\n      }\n\n      if (end === -1) return ''\n      return path.slice(start, end)\n    }\n  },\n\n  extname: function extname(path) {\n    path = sketchSpecifics.getString(path, 'path')\n    var startDot = -1\n    var startPart = 0\n    var end = -1\n    var matchedSlash = true\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i)\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1\n          break\n        }\n        continue\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false\n        end = i + 1\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i\n        else if (preDotState !== 1) preDotState = 1\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1\n      }\n    }\n\n    if (\n      startDot === -1 ||\n      end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n    ) {\n      return ''\n    }\n    return path.slice(startDot, end)\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new Error('pathObject should be an Object')\n    }\n    return _format('/', pathObject)\n  },\n\n  parse: function parse(path) {\n    path = sketchSpecifics.getString(path, 'path')\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' }\n    if (path.length === 0) return ret\n    var code = path.charCodeAt(0)\n    var isAbsolute = code === CHAR_FORWARD_SLASH\n    var start\n    if (isAbsolute) {\n      ret.root = '/'\n      start = 1\n    } else {\n      start = 0\n    }\n    var startDot = -1\n    var startPart = 0\n    var end = -1\n    var matchedSlash = true\n    var i = path.length - 1\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i)\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1\n          break\n        }\n        continue\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false\n        end = i + 1\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i\n        else if (preDotState !== 1) preDotState = 1\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1\n      }\n    }\n\n    if (\n      startDot === -1 ||\n      end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n    ) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path.slice(1, end)\n        else ret.base = ret.name = path.slice(startPart, end)\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot)\n        ret.base = path.slice(1, end)\n      } else {\n        ret.name = path.slice(startPart, startDot)\n        ret.base = path.slice(startPart, end)\n      }\n      ret.ext = path.slice(startDot, end)\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1)\n    else if (isAbsolute) ret.dir = '/'\n\n    return ret\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null,\n\n  resourcePath: sketchSpecifics.resourcePath,\n}\n\nmodule.exports = posix\nmodule.exports.posix = posix\n","var util = require('util')\n\nmodule.exports.getString = function getString(path, argumentName) {\n  if (!util.isString(path)) {\n    // let's make a special case for NSURL\n    if (util.getNativeClass(path) === 'NSURL') {\n      return String(path.path().copy())\n    }\n    throw new Error(argumentName + ' should be a string. Got ' + typeof path + ' instead.')\n  }\n  return String(path)\n}\n\nmodule.exports.cwd = function cwd() {\n  if (typeof __command !== 'undefined' && __command.script() && __command.script().URL()) {\n    return String(__command.script().URL().path().copy())\n  }\n  return String(MSPluginManager.defaultPluginURL().path().copy())\n}\n\nmodule.exports.resourcePath = function resourcePath(resourceName) {\n  if (typeof __command === 'undefined' || !__command.pluginBundle()) {\n    return undefined\n  }\n  var resource = __command.pluginBundle().urlForResourceNamed(resourceName)\n  if (!resource) {\n    return undefined\n  }\n  return String(resource.path())\n}\n","import DOM from \"sketch/dom\";\nimport UI from \"sketch/ui\";\nimport fs from \"@skpm/fs\";\nimport path from \"@skpm/path\";\nimport * as utils from \"./utilities/utilities\";\n\nconst deleteSelection = () => {\n  const document = DOM.getSelectedDocument();\n  const documentId = document.id;\n\n  const scriptPath = path.resolve(\"..\");\n  const documentFilePath = `${scriptPath}/selections/${documentId}.txt`;\n\n  if (fs.existsSync(documentFilePath)) {\n    const data = fs.readFileSync(documentFilePath);\n    const documentFile = JSON.parse(data);\n\n    let options = [];\n    for (let i = 0; i < documentFile.selectionsArray.length; i++) {\n      options.push(documentFile.selectionsArray[i].selectionName);\n    }\n\n    UI.getInputFromUser(\n      \"Choose a selection to delete\",\n      {\n        type: UI.INPUT_TYPE.selection,\n        possibleValues: options,\n      },\n      (err, value) => {\n        if (err) return;\n\n        for (let i = 0; i < documentFile.selectionsArray.length; i++) {\n          if (value === documentFile.selectionsArray[i].selectionName) {\n            documentFile.selectionsArray.splice(i, 1);\n          }\n        }\n\n        if (documentFile.selectionsArray.length === 0) {\n          fs.unlinkSync(documentFilePath);\n        } else {\n          fs.writeFileSync(documentFilePath, JSON.stringify(documentFile));\n        }\n      }\n    );\n  } else {\n    utils.showToast(\"There are no selections saved for this document.\");\n  }\n};\n\nexport { deleteSelection };\n","import Settings from \"sketch/settings\";\nimport UI from \"sketch/ui\";\n\n/* \nSaves a global setting in Sketch to the provided key\n*/\nconst saveGlobalSetting = (key, value) => {\n  Settings.setGlobalSettingForKey(key, value);\n};\n\n/* \nLoads a global setting in Sketch to the provided key\n*/\nconst loadGlobalSetting = (key) => {\n  return Settings.globalSettingForKey(key);\n};\n\n/* \nSaves a plugin setting in Sketch to the provided key\n*/\nconst savePluginSetting = (key, value) => {\n  Settings.setSettingForKey(`com.mfouquet.sketch.reselect.${key}`, value);\n};\n\n/* \nLoads a plugin setting in Sketch with the provided key\n*/\nconst loadPluginSetting = (key) => {\n  return Settings.settingForKey(`com.mfouquet.sketch.reselect.${key}`);\n};\n\n/* \nSaves a session variable in Sketch to the provided key\n*/\nconst saveSessionVariable = (key, value) => {\n  Settings.setSessionVariable(`com.mfouquet.sketch.reselect.${key}`, value);\n};\n\n/* \nLoads a session variable in Sketch with the provided key\n*/\nconst loadSessionVariable = (key) => {\n  return Settings.sessionVariable(`com.mfouquet.sketch.reselect.${key}`);\n};\n\n/* \nOpens a URL from Sketch\n*/\nconst openURL = (url) => {\n  const nsurl = NSURL.URLWithString(url);\n  NSWorkspace.sharedWorkspace().openURL(nsurl);\n};\n\n/*\nShows a message at the bottom of the Sketch window\n*/\nconst showToast = (message) => {\n  UI.message(message);\n};\n\nexport {\n  saveGlobalSetting,\n  loadGlobalSetting,\n  savePluginSetting,\n  loadPluginSetting,\n  saveSessionVariable,\n  loadSessionVariable,\n  openURL,\n  showToast,\n};\n","module.exports = require(\"buffer\");","module.exports = require(\"sketch/dom\");","module.exports = require(\"sketch/settings\");","module.exports = require(\"sketch/ui\");","module.exports = require(\"util\");"],"sourceRoot":""}